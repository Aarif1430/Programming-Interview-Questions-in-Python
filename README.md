# Leetcode-Solutions
After doing over 120+ questions from EPI, CTCI and leetcode combined, I've hand selected questions I believe every software engineer needs to complete in preparation for the Big N whiteboarding interviews. These are questions, I believe will give the most bang for your buck and investment on time. Worthy of adding to your arsenal to fight the coding gods! 

Each question has its own unique 'gotcha' that you should learn. You want to take each question to the most optimal solution in-order to fully maximize what you can learn from it. Some questions are onion questions, with multiple solutions to the problem, its also important to know them all. For example, do it both recursive and iteratively or BFS and DFS. 

# Mindset approach to Whiteboard interviews
Attempting to pass whiteboard interviews is a daunting task. No one is born natural to it. That is why I'd like to set a tone and mindset when I approach almost anything that I am unfamiliar with. Here are a few quick tips that can get you started.

#### Prepare to fail
You will fail. Accept it. However, DO NOT ALLOW it to dictate your future actions. There is only one effective way to deal with failure. That is to learn from it. Learn as much as you can from the choices you have made. In this case, that means, learn what you can from each question, encounter and process. This is why this will lead up to my next point.

#### Play to learn, not play to win
Yes you want that Big N job, we all want it. However, you cannot get that job unless you start shifting your objective from "winning" to "learning". "Winning" should never be your first objective, your first objective is to "learn". Why? For some, if "winning" was their first objective, they run into starter paralysis aka. fear. Afraid to lose. When "winning" or "losing" becomes your first priority, you become blinded from how the process can take you there. Don't get me wrong, having a goal to win is important, but remember, its just a long term goal, not an obstacle.

# How to learn?
Now this brings me to this dicussion on how one should effectively learn. First, one must understand the different phases of learning. 

Take typing on a keyboard as an example. Before you can type on the keyboard, one must memory map the action they want to do to each key press on the keyboard. For our case, this is an example of python language syntax. Like how a keyboard is a tool, the language one chooses to program in, is also a tool. 

What if you don't know what to type on the keyboard? Now that is related to the set of english words or grammar rules one knows. For us that is the data structures and algothrims a programmer needs to utalize their tool.

Say you have mastered both your english language and your keyboard is there another learning phase? Of course, just like one starts small and build their way up, one can end up from small to large. We need a way to manage our end result and this leads to structure. Without structure, there isn't a good way to maintain and keep it from collapsing. To programmers, those are design patterns, SOLID principles and take your pick of programming paradigms.

In conclusion, when you are stuck on a problem, think about which learn phase your are stuck on. Is it the lack of DS/Algos, the language, or programming paradigms? One you are able to figure that out, focus on that part of your missing knowledge. It will be diffcult when you start, as for another starting something new, there is usually more than one knowledge area that is missing.

# How should you practice for whiteboard coding questions

### Basics
- #1. Two Sum
- #141. Linked List Cycle
- #7. Reverse Integer
- #29. Divide Two Integers
- #404. Sum of Left Leaves
- #367. Valid Perfect Square

### Hash Tables

### Linked lists

### Heaps

### Pointers
- #138. Copy List With Random Pointer

### Sorting
- #215. Kth Largest Element in an Array	

### Stacks
- #402. Remove K Digits

### Intro to dynamic programming
- #198. House Robber
- #221. Maximal Square

### Into the weeds with dynamic programming
- #139. Word Break
- #516. Longest Palindromic Subsequence

### How you structure your code
#### These question are fairly straight forward, no trick questions or gotchas here. You should try to improve and shave the excess fat off your code when trying to solve this. If an interviewer asks you one of these questions, it is to test your ability to write 'clean' code, not how you utalize DS or Algos.
- #36. Valid Sudoku
- #289. Game of Life

### Combine more than one data structure
#### You may start these questions once the above questions have been completed. These set of questions test your ability to combine more than one data structure together to create an efficent solution. A must do, as it will greatly strengthen your ability to establish relationships between data structures.
- #146. LRU Cache
- #355. Design Twitter
- #380. Insert Delete GetRandom O(1)

### How you think
#### These questions can be diffcult if you use the wrong data structure or set of logic, but is quite easy once you focus on 'how' the solution is built. Try to use a simple test case but focus purely on the lowest denominator solution. What's makes a trapped rain water? Or what makes a zig zag a zig zag?
- #42. Trapping Rain Water
- #6. ZigZag Conversion
