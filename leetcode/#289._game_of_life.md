```
class Solution(object):
    def gameOfLife(self, board):
        """
        :type board: List[List[int]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        result_board = copy.deepcopy(board)
        for row_index in range(0, len(board)):
            for col_index in range(0, len(board[0])):
                cell = (row_index, col_index)
                n_neighbors = self.count_live_neighbors(cell, board)
                value_at_cell = board[row_index][col_index]
                if value_at_cell == 1: # a live cell
                    if n_neighbors < 2 or n_neighbors > 3:
                        result_board[row_index][col_index] = 0
                elif n_neighbors == 3: # a dead cell
                    result_board[row_index][col_index] = 1
        for row_index in range(0, len(board)):
            for col_index in range(0, len(board[0])):
                board[row_index][col_index] = result_board[row_index][col_index]
    
    def count_live_neighbors(self, curr_cell, board):
        row_index = curr_cell[0]
        col_index = curr_cell[1]
        directions = [(-1,-1), (0,-1), (1,-1), (-1,0), (1,0), (-1,1), (0,1), (1,1)]
        n_neighbors = 0
        for direction in directions:
            next_row_index = row_index + direction[0]
            next_col_index = col_index + direction[1]
            if self.is_cell_live(next_row_index, next_col_index, board):
                n_neighbors += 1
        return n_neighbors
    
    def is_cell_live(self, row_i, col_i, board):
        if self.within_bounds(row_i, col_i, board) and board[row_i][col_i] == 1:
            return True
        return False
                
    def within_bounds(self, row_i, col_i, board):
        if row_i >= 0 and col_i >= 0 and row_i < len(board) and col_i < len(board[0]):
            return True
        return False
```
